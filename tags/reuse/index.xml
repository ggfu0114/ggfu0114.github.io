<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reuse on GGfu Personal Study - 學習筆記</title><link>https://ggfu0114.github.io/tags/reuse/</link><description>Recent content in reuse on GGfu Personal Study - 學習筆記</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><atom:link href="https://ggfu0114.github.io/tags/reuse/index.xml" rel="self" type="application/rss+xml"/><item><title>Dev issue: Lambda reuse</title><link>https://ggfu0114.github.io/posts/dev-issue_-lambda-reuse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ggfu0114.github.io/posts/dev-issue_-lambda-reuse/</guid><description>當系統透過 APIGateway 呼叫 Lambda 執行時，我以為Lambda會全部重新執行打包好的程式。所以開發時，我們將 database connection 物件當成 Global 物件使用，認為每次重新呼叫 Lambda 都會全部重新生成物件。因為這個觀念而導致系統錯誤，當 Project 的物件被 require 後或變成 global 參數，再次執行 Lambda container 會出現 reuse 特性，將不會再被重新執行而生成新物件，以下是一個範例。 DB 的 client 為 global 物件
const pg = require(&amp;#39;pg&amp;#39;); const client = new pg.Client(&amp;#39;postgres://myrds:5432/dbname&amp;#39;); client.connect(); exports.handler = (event, context, cb) =&amp;gt; { const {test_print} = require(&amp;#39;./example_module&amp;#39;); test_print(); client.query(&amp;#39;SELECT * FROM users WHERE &amp;#39;, (err, users) =&amp;gt; { // Do stuff with users cb(null); // Finish the function cleanly }); }; 上面的範例，因為 client 為 global物件，所以如果在程式裡面有 disconnect client 的狀況下，再次執行 Lambda 就會出現錯誤，因為 client 物件沒被重新 connect。 Global 程式不會每次都被執行</description></item></channel></rss>